use std::str::FromStr;
use crate::ast;
use crate::ast::{Expr, Opcode};

grammar;

UpperTerm : ast::UpperTerm = {
    r"[A-Z][A-Za-z_]*" => String::from_str(<>).unwrap()
}

Enum : ast::Enum = {
    <name:UpperTerm> "::" "{" <terms:Comma<UpperTerm>> "}." => ast::Enum {
        name,
        terms,
    }
}

Params: Vec<ast::UpperTerm> = {
    <v:(<UpperTerm> "x")*> <e:UpperTerm?> => match e {
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

FunctionDeclaration : ast::FunctionDeclaration = {
    <name:UpperTerm> ":" <ret:UpperTerm> => ast::FunctionDeclaration {
        name,
        params: None,
        ret
    },
    <name:UpperTerm> ":" <params:Params> "->" <ret:UpperTerm> => ast::FunctionDeclaration {
        name,
        params: Some(params),
        ret
    }
}

Sort: ast::Sort = {
    <name:UpperTerm> "::" <parent_sorts:Comma<UpperTerm>> "." => ast::Sort {
        name,
        parent_sorts,
        attributes: None
    },
    <name:UpperTerm> "::" <parent_sorts:Comma<UpperTerm>>
        "attributes"
        <attrs: FunctionDeclaration+>
        "."
        => ast::Sort {
            name,
            parent_sorts,
            attributes: Some(attrs)
        }
}


pub ALMModule: ast::ALMModule = {
    "module Window_demo"
    "enums"
        <enums:Enum+>
    "sorts"
        <sorts:Sort+>
    "statics"
        <statics:FunctionDeclaration+>
    "fluents
        basic
            Grouped_With : Rectangles x Rectangles -> Booleans
            Moving : Rectangles -> Booleans
        defined
            output Side : Rectangles x Directions -> Booleans.
            Distance : Rectangles x Rectangles x Integers -> Booleans
    axioms
        Snapping_Threshold = 30

        Opposite_Direction(a) = b if
            Opposite_Direction(b) = a.
        
        Opposite_Direction(DLeft) = DRight.
        
        Distance(a, b, min_d) if
            Instance(a, Rectangles),
            Instance(b, Rectangles),
            -Overlaps(a, b),
            Opposite_Direction(dir) = dir',
            #ddlog var min_d = Aggregate((a, b), group_min(b)).
        
        Moving(other) = false if
            Instance(other, Rectangles),
            -Grouped_With(other, _).


" => ast::ALMModule {
        enums,
        sorts,
        statics,
        fluents: ast::Fluents {
            basic: vec![],
            defined: vec![],
        },
        axioms: vec![],
    }
}

pub Exprs = Comma<Expr>;

Comma<T>: Vec<T> = { // (0)
    <v:(<T> ",")*> <e:T?> => match e { // (1)
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Tier<Op,NextTier>: Box<Expr> = {
    Tier<Op,NextTier> Op NextTier => Box::new(Expr::Op(<>)),
    NextTier
};

Expr = Tier<ExprOp, Factor>;
Factor = Tier<FactorOp, Term>;

ExprOp: Opcode = { // (3)
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
};

Term: Box<Expr> = {
    Num => Box::new(Expr::Number(<>)),
    "(" <Expr> ")"
};

Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap()
};
